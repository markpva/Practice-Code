# -*- coding: utf-8 -*-
"""Working Code Practice.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1veUHEDGvsCdwY8ybhE8PGBlmW5iJyE57
"""

print("Decimal basis to Binary basis")

n=int(input("Enter Number to get equivalent Binary Number"))
l=list()
while n!=0:
    r=n%2
    l.append(r)
    n=n//2
print(l)

print("Binary basis to Decimal basis")

n=input("Enter Binary Number to get equivalent Decimal Number")
n=int(n)

dec,i = 0,0

while n>0:
    r=n%10
    exp=r*(2**i)
    dec=dec+exp
    n=n//10
    i+-1
print("Decimal number:",dec)

import numpy as np
from scipy import linalg
from numpy.core.numeric import ones
import sys
import cmath as cm

ut=np.array([[3.0,2.0,-1.0],[0.0,-2.0,-1.0],[0.0,0.0,6.0]])
print("ut, upper triangular")
print(ut)
b=np.array([-3.0,-1.0,2.0])
print("\nb, right hand")
print(b)
 
# backward substitution
idim=len(b)
x = np.zeros(idim)
for i in range(idim-1,-1,-1): # i is row number
  #xi = bi
  x[i] = b[i]
  for j in range(i+1,idim): # j is column number
    #xi = xi = utij*xj
    x[i] = x[i] - ut[i][j]*x[j]
  #xi = xi / uii
  x[i] = x[i]/ut[i][i]

  #output
print("\nx, solutions")
print(x)
print("npX,\n\n",np.linalg.solve(ut,b),"\n")

import math
from decimal import Decimal, getcontext
getcontext().prec = 6 

print("Problem 1.7")

x = Decimal(5.5) 
y = Decimal(0.) # y = e^x

# get e^(5.5) with the system value of e
y_base = Decimal(math.pow(np.e,x))
print("system:  e^5.5 = {0:.8f}".format(y_base)," e^-5.5 = {0:.8f}".format(Decimal(1)/y_base))

n = 20 
for i in range(n):
  dy = pow(x,i)/math.factorial(i)
  y += dy
print("approx:  e^5.5 = {0:.8f}".format(y)," e^-5.5 = {0:.8f}".format(Decimal(1)/y),", for {} terms".format(n))

iy_book = Decimal(.0026363) 
print("book  :  e^5.5 = {0:.8f}".format(Decimal(1)/iy_book)," e^-5.5 = {0:.8f}".format(iy_book),", former reconstituted from latter")

import numpy as np

# as function so as to reuse
def synthetic(ac,ax,ak = None):
  """
  ac[]    : [c0,c1,...,cn-1] st c0*x^0,c1*x^1,...,cn-1*x^(n-1)
  ax      : x to evaluate
  ak      : degree of coefficient to return; default = all

  returns : update to ac
  """
  n = len(ac)
  f = np.copy(ac) 
  
  if ak is None:
    for j in range(1,n):
      for i in range(n-1, j-1,-1):
        f[i-1] = f[i]*ax + f[i-1]    

  return f


def main():
  c = np.array([5.,-2.,3.,-4.,1.])
  x = 1.5

  p = synthetic(c,x)
  dx = x-(p[0]/p[1]) # the first two coeffs are f,f' ~ x,new = x,old - f/f'
  print(f"q2 synthetic division: x, next     = {dx}")
  print(f"q2 synthetic division: derivatives = {p}")

if __name__ == "__main__":
  main()